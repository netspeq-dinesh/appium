"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogMonitor = void 0;
const asyncbox_1 = require("asyncbox");
const DEFAULT_MAX_RETRY_COUNT = 10;
const DEFAULT_BACKOFF_TIME_MS = 3000;
class LogMonitor {
    constructor(logsEmitter, filter) {
        this._logsEmitter = logsEmitter;
        this._outputListener = null;
        this._filter = filter;
    }
    get started() {
        return Boolean(this._outputListener);
    }
    clearlastMatch() {
        this._lastMatch = null;
    }
    get lastMatch() {
        return this._lastMatch;
    }
    async waitForLastMatchExist(maxRetryCount = DEFAULT_MAX_RETRY_COUNT, retryBackoffTime = DEFAULT_BACKOFF_TIME_MS) {
        return await (0, asyncbox_1.retryInterval)(maxRetryCount, retryBackoffTime, async () => {
            if (this._lastMatch !== null) {
                return this._lastMatch;
            }
            throw new Error(`No matched log found with ${retryBackoffTime} ms interval ` +
                `up to ${maxRetryCount} times. Increasing appium:retryBackoffTime ` +
                `and appium:maxRetryCount would help.`);
        });
    }
    ;
    start() {
        if (this.started) {
            return this;
        }
        this._outputListener = this._onOutput.bind(this);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this._logsEmitter.on('output', this._outputListener);
        return this;
    }
    stop() {
        if (!this.started) {
            return this;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this._logsEmitter.off('output', this._outputListener);
        this._outputListener = null;
        return this;
    }
    async _onOutput(logEntry) {
        if (await this._filter(logEntry)) {
            this._lastMatch = logEntry;
        }
    }
}
exports.LogMonitor = LogMonitor;
//# sourceMappingURL=log-monitor.js.map